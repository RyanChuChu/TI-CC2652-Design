;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;                                    HW5                                     ;
;                            Servomotor Interface                            ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Description:      This program demonstrates the operations of a servomotor
;                   MG996R control system. The software initializes power, clocks,
;                   GPIO pins, internal timers and analog-to-digital converter,   
;                   then controls a servomotor's position through SetServo with
;                   1 degree resolution, gets the current position by GetServo,
;                   and turns off servo for manual setting by ReleaseServo. The  
;                   test loop utilizes a test table and sequentially executes 
;                   each command with a 300 ms delay between each test cases.
;                
; Input:            DIO23 captures the analog feedback from servomotor, and pass
;                   the signal to ADC for conversion in GetServo.
;                   
; Output:           DIO3 outputs a PWM signal generated by GPT1A, changing the
;                   position of servomotor to specified angle by varying the duty
;                   cycle of PWM signal in SetServo, and reset to 0 in ReleaseServo
;
; User Interface:   The user controls the behavior of servomotor through
;                   pre-configured test table, and check the status of 
;                   SetServo and the current angle computed by Getservo
;                   on LCD.
;
; Error Handling:   SetServo handle invalid input angle by displaying "Invalid" on 
;                   the LCD and no PWM update occurs.
;
; Algorithms:       The system utilizes linear mapping for both converting angle to
;                   PWM duty cycle in SetServo, and converting ADC data to angle in
;                   GetServo. The ADC is manually triggered in GetServo on demand to
;                   preserve hardware resources. LCD is utilized for SetServo invalid
;                   input and for GetServo return value. Both SetServo and GetServo 
;                   have 1 degree resolution.
;                   
; Data Structures:  LCD initialization table and servomotor test table.
;                   
; Revision History:
;     12/10/25  Li-Yu Chu      initial revision
;     12/12/25  Li-Yu Chu      update comments



; local include files
        .include  "CPUreg.inc"
        .include  "GPIOreg.inc"
        .include  "IOCreg.inc"
        .include  "GPTreg.inc"
        .include  "constant.inc"
        .include  "macro.inc"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; data
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        .sect   ".const"
        .align  4
LCDInitTab:
                ;Command            Delay Count
        .word   00111000b,   20000 * CLK_PER_US
        .word   00111000b,    4100 * CLK_PER_US
        .word   00111000b,     100 * CLK_PER_US
        .word   00111000b,       NO_DELAY_COUNT         ;function set
        .word   00001000b,       NO_DELAY_COUNT         ;display off
        .word   00000001b,       NO_DELAY_COUNT         ;clear display
        .word   00000110b,       NO_DELAY_COUNT         ;entry mode set
        .word   00001111b,       NO_DELAY_COUNT         ;display/cursor on  

EndLCDInitTab:

        ;servomotor test table
        .align 4  
TestServoMotorTab:

                ;operation      ;argument(if any)
        .byte           0,                    100
        .byte           0,                      0
        .byte           1
        .byte           0,                     45
        .byte           1
        .byte           0,                     90
        .byte           1
        .byte           0,                    -90
        .byte           1
        .byte           0,                     20
        .byte           1
        .byte           0,                     25
        .byte           1
        .byte           0,                     30
        .byte           1
        .byte           2


EndTestServoMotorTab:


        .data
        
        ;initialization functions
        .ref    InitPower               ;turn on power to everything
        .ref    InitClocks              ;turn on clocks to everything
        .ref    InitGPIO                ;setup the I/O pins for servomotor
        .ref    InitGPT0                ;initialize the general purpose timer
        .ref    InitADC                 ;initialize analog-to-digital converter

        ;servomotor timer initialization
        .ref    InitServoGPT

        ;imported servomotor functions
        .global SetServo                ;set servomotor position to specific angle 
        .global GetServo                ;return the current position of servo in degrees
        .global ReleaseServo            ;turn off the servo for manual setting

        ;LCD functions
        .ref    InitLCD                 ;LCD initialization

        ; the stack (must be double-word aligned)
        .align  8
TopOfStack:     .space  TOTAL_STACK_SIZE

        ; variables

        .align  4

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; code
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   
        .text
        .global resetISR                     ;reset interrupt service routine

resetISR:

main:
        MOVA    R0, TopOfStack               ;initialize the stack pointers
        MSR     MSP, R0                      ;Main Stack Pointer
        SUB     R0, R0, #HANDLER_STACK_SIZE
        MSR     PSP, R0                      ;Process Stack Pointer

        BL      InitPower                    ;turn on power to everything
        BL      InitClocks                   ;turn on clocks to everything
        BL      InitGPIO                     ;setup the I/O pins for servomotor

        BL      InitGPT0                     ;initialize the internal timers
        BL      InitServoGPT                 ;intialize timer for servo motors
        BL      InitADC                      ;initialize analog-to-digital converter

        MOVA    R1, LCDInitTab               ;get start address of LCD initialization table
        MOVA    R2, EndLCDInitTab            ;get end address of LCD initialization table
        BL      InitLCD                      ;initialize LCD

        MOVA    R3, TestServoMotorTab        ;get the start address of test table
        MOVA    R4, EndTestServoMotorTab     ;get the end address of test table

        B       TestServoMotor               ;start testing

TestServoMotor: 

        LDRB    R1, [R3], #1                 ;load operation code and call functions respectively
                                             ;0 - SetServo
                                             ;1 - GetServo
                                             ;2 - ReleaseServo

        TEQ     R1, #SETSERVO_OPCODE    
        BEQ     CallSetServo

        TEQ     R1, #GETSERVO_OPCODE
        BEQ     CallGetServo

        TEQ     R1, #RELEASESERVO_OPCODE
        BEQ     CallReleaseServo

        B       DoneTest                     ;invalid test opcode

CallSetServo:

        LDRSB   R0, [R3], #1                 ;load argument (angle)
        BL      SetServo                        
        
        B       MainPrevTimeout              ;wait for delay between test cases

CallGetServo:

        BL      GetServo                     ;no input argument

        B       MainPrevTimeout              ;wait for delay between test cases

CallReleaseServo:

        BL      ReleaseServo                 ;no input argument

        B       MainPrevTimeout              ;wait for delay between test cases

MainPrevTimeout:
                                                ;wait for previous timeout
        MOV32   R1, GPT0_BASE_ADDR              ;get base address of GPT0
        LDR     R0, [R1, #GPT_RIS_OFF]          ;get timer 0 raw interrupt status
        TEQ     R0, #GPT0_TIMEOUT               ;check if timeout interrupt generated
        BNE     MainPrevTimeout                 ;if not, wait until timeout
        ;BEQ    SetupMainDelay                  ;if yes, check the type of new delay

SetupMainDelay:
                                                ;wait a new delay between test cases
        STREG   GPT_IRQ_TATO, R1, GPT_ICLR_OFF  ;clear previous timeout
        STREG   MAIN_DELAY, R1, GPT_TAILR_OFF   ;setup 300ms timer
        STREG   GPT_CTL_TAEN, R1, GPT_CTL_OFF   ;enable timer 0
        ;B      MainWaitDelay

MainWaitDelay:

        LDR     R0, [R1, #GPT_RIS_OFF]          ;get timer 0 raw interrupt status
        TEQ     R0, #GPT0_TIMEOUT               ;check if timeout interrupt generated
        BNE     MainWaitDelay                   ;if not, wait until timeout
        ;BEQ    DoneCall                        ;if yes, check if there's still test cases

DoneTest:

        TEQ     R3, R4                          ;check if it's end of test table
        BNE     TestServoMotor                  ;if not, loop next command

        BEQ     DoneTest                        ;if yes, stay in forever loop

        .end